// Loosely based on postprocessing shader by inigo quilez, License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.

vec2 curve(vec2 uv)
{
	uv = (uv - 0.5) * 2.0;
	uv *= 1.1;	
	uv.x *= 1.0 + pow((abs(uv.y) / 5.0), 2.0);
	uv.y *= 1.0 + pow((abs(uv.x) / 4.0), 2.0);
	uv  = (uv / 2.0) + 0.5;
	uv =  uv *0.92 + 0.04;
	return uv;
}
void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    const bool useCurve = false;
    const bool useVignette = true;
    const bool useScanlines = true;
    const bool useDotMatrix = true;
    const bool useNoiseLines = false;
    const bool useBleeding = false;
    
    const float colorCurve = 0.4;
    const float bonusLight = 0.05;
    
    vec2 q = fragCoord.xy / iResolution.xy;
    vec2 uv = q;
    if (useCurve)
       uv = curve( uv );
    
    vec3 oricol = texture( iChannel0, vec2(q.x,q.y) ).xyz;
    vec3 col;
    
    // "x" is a series of horizontal noise lines that disappear and appear.
    float x = 0.0;
    
    if (useNoiseLines) 
	  x = sin(0.3*iTime+uv.y*21.0)*sin(0.7*iTime+uv.y*29.0)*sin(0.3+0.33*iTime+uv.y*31.0)*0.0017;    
    
    
    // each channel samples the original texture with a slightly different UV offset.
    // note also that each channel also adds 0.05.    
    col.r = texture(iChannel0,vec2(x+uv.x+0.001,uv.y+0.001)).x; // red is sampled from bottom-right
    col.g = texture(iChannel0,vec2(x+uv.x+0.000,uv.y-0.002)).y; // green is sampled from below
    col.b = texture(iChannel0,vec2(x+uv.x-0.002,uv.y+0.000)).z; // blue is sampled from slightly to the right
    
    col += bonusLight;
    
    // bleeding?
    if (useBleeding) {
    
        // to each color channel, add a small portion of the pixel that is elsewhere
        // (with a complex relationship with "x" factor)
    
        col.r += 0.08*texture(iChannel0,0.75*vec2(x+ 0.025, -0.027) + vec2(uv.x+0.001,uv.y+0.001)).x;
        col.g += 0.05*texture(iChannel0,0.75*vec2(x+-0.022, -0.02)  + vec2(uv.x+0.000,uv.y-0.002)).y;
        col.b += 0.08*texture(iChannel0,0.75*vec2(x+-0.02, -0.018)  + vec2(uv.x-0.002,uv.y+0.000)).z;
    }
    
    // subtle color curve:
    col = clamp(col*(1.0 - colorCurve) + colorCurve*col*col ,0.0 ,1.0);

    // vignette:
    if (useVignette) {
        float vig = (0.0 + 1.0*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y));
        col *= vec3(pow(vig,0.3));
    }
    
    // color balance towards green
    col *= vec3(0.95,1.05,0.95); 
    
    if (useScanlines) {
        col *= 2.8;
        float scans = clamp( 0.35+0.35*sin(3.5*iTime + uv.y*iResolution.y*1.5), 0.0, 1.0);	
        float s = pow(scans,1.7); // 
        col = col * (0.4 + 0.7*s); // and yes, this means we boost color by 1.1 (in addition to 2.8). Probably to offset the luma lost by "scans"
    }

    // add a very slight flicker
    col *= 1.0+0.01*sin(110.0*iTime);
    
	if (uv.x < 0.0 || uv.x > 1.0) col *= 0.0;
	if (uv.y < 0.0 || uv.y > 1.0) col *= 0.0;
    
    if (useDotMatrix) 
        // "horizontal" component of the scanlining aka dotmatrixing
        col*=1.0-0.65*vec3(clamp((mod(fragCoord.x, 2.0)-1.0)*2.0,0.0,1.0));

    fragColor = vec4(col,1.0);
}